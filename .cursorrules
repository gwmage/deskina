# Deskina 프로젝트 작업 규칙

이 문서는 Deskina AI 에이전트 개발 프로젝트의 구조, 핵심 기능, 기술 스택, 그리고 주요 개발 규칙을 정의합니다. AI 어시스턴트는 이 규칙을 숙지하고 개발에 임해야 합니다.

## I. 프로젝트 구조

- **`client/`**: React와 Electron 기반의 데스크톱 클라이언트 애플리케이션입니다.
  - **주요 파일**: `client/src/App.js`
  - **역할**: UI 렌더링, 사용자 입력 처리, 서버와의 통신, OS 명령어 실행(`child_process`)을 담당합니다.
- **`server/`**: NestJS 기반의 백엔드 서버입니다.
  - **주요 파일**: `server/src/gemini/gemini.service.ts`, `server/src/session/session.service.ts`
  - **역할**: OpenAI/Gemini API 연동, 시스템 프롬프트 관리, 대화 세션 관리, DB 연동을 담당합니다.
- **`eposo-docs/`**: 프로젝트의 기능 명세 및 개발 계획을 담은 문서 폴더입니다.
- **`prisma/`**: Prisma 스키마(`schema.prisma`)와 데이터베이스 파일(`dev.db`)을 관리합니다.

## II. 주요 기술 스택

- **클라이언트**: React, Electron, `electron-ipc-renderer`, `child_process`
- **서버**: NestJS, `@google/generative-ai`, Prisma
- **데이터베이스**: SQLite (Prisma를 통해 관리)
- **통신**: `fetch` API 스트리밍 방식 (POST)

## III. 핵심 기능 및 동작 원리

### 1. OS 명령어 실행

- **흐름**:
  1.  사용자가 "C 드라이브 파일 목록 보여줘"와 같은 자연어 명령을 입력합니다.
  2.  클라이언트는 `navigator.platform`으로 현재 OS 정보("win32", "darwin" 등)를 식별하여 서버에 함께 전송합니다.
  3.  서버의 `gemini.service.ts`는 시스템 프롬프트를 통해 AI에게 OS에 맞는 명령어를 생성하도록 지시합니다. (예: Windows -> `dir C:\`, macOS -> `ls -l /`)
  4.  AI는 `runCommand` 도구를 사용하여 실행할 명령어를 응답으로 생성합니다.
  5.  서버는 이 응답을 클라이언트에 스트리밍으로 전달합니다.
  6.  클라이언트의 `App.js`는 `runCommand` 응답을 감지하고, Electron의 `ipcRenderer`를 통해 메인 프로세스에 명령어 실행을 요청합니다.
  7.  메인 프로세스의 `child_process.exec`가 실제 셸 명령어를 실행하고, 그 결과를 다시 렌더러 프로세스로 보내 UI에 표시합니다.

- **중요 규칙**:
  - **OS 인지**: AI는 반드시 클라이언트로부터 전달받은 OS 정보를 바탕으로 명령어를 생성해야 합니다.
  - **오류 처리**: 명령어 실행 실패 시, AI는 같은 명령을 반복하지 않고 사용자에게 다음 행동을 물어야 합니다. 이는 시스템 프롬프트에 명시되어 있습니다.

### 2. 이미지 처리 (멀티모달)

- **흐름**:
  1.  사용자가 채팅 입력창의 클립(📎) 버튼을 눌러 이미지를 첨부합니다.
  2.  첨부된 이미지는 Base64로 인코딩되어 프롬프트와 함께 서버로 전송됩니다.
  3.  서버는 텍스트 프롬프트와 이미지 데이터를 함께 Gemini API로 전달합니다.
  4.  AI는 이미지를 분석하고 관련된 작업을 수행하거나 답변을 생성합니다.

- **통신 방식**: 대용량 이미지 데이터를 전송하기 위해 기존의 `EventSource`(GET)에서 `fetch` API 스트리밍(POST) 방식으로 전환되었습니다.

### 3. 페이지네이션 (성능 최적화)

- **흐름**:
  1.  채팅창이 처음 로드될 때 최근 대화 기록만 불러옵니다.
  2.  사용자가 채팅창 최상단의 "이전 대화 불러오기" 버튼을 클릭합니다.
  3.  클라이언트는 `page`와 `limit` 파라미터를 사용하여 서버의 세션 API에 이전 기록을 요청합니다.
  4.  서버는 Prisma의 `skip`과 `take`을 이용해 DB에서 해당 범위의 데이터를 조회하여 반환합니다.
  5.  클라이언트는 받아온 데이터를 기존 대화 목록의 맨 앞에 추가하고, 스크롤 위치를 유지하여 사용자 경험을 해치지 않습니다.

## IV. 개발 규칙 및 제약사항

1.  **응답 언어**: 모든 소통과 코드 주석, UI 텍스트는 **한국어**를 기본으로 합니다.
2.  **API 오류 처리**: 서버의 API 컨트롤러(`gemini.controller.ts`)는 `try...catch` 블록을 통해 외부 API(Gemini) 호출 오류를 처리해야 합니다. 오류 발생 시, "API 사용량을 초과했습니다."와 같이 사용자 친화적인 메시지를 클라이언트에 전달해야 합니다.
3.  **무한 루프 방지**: AI가 특정 작업(특히 명령어 실행) 실패 시 동일한 행동을 반복하지 않도록 시스템 프롬프트에 강력한 제어 규칙을 포함시켜야 합니다. 사용자가 작업을 강제 중단할 수 있는 '중지' 버튼과 `AbortController` 로직은 필수입니다.
4.  **상태 관리**: 클라이언트의 상태(대화 기록, 로딩 상태, 오류 메시지 등)는 `useState`와 `useRef`를 중심으로 관리하며, 복잡한 전역 상태 관리 라이브러리는 현재 사용하지 않습니다.
5.  **UI/UX**: 기능 구현 시 항상 사용자 경험을 고려해야 합니다. (예: 페이지네이션 시 스크롤 위치 유지, 이미지 미리보기 및 제거 기능) 
6.  시킨 것만 작업한다. 기존 내용을 건드려서 정상적으로 돌아가는 시스템에 영향을 주면 절대 안 된다.