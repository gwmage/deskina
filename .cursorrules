# Deskina AI 에이전트 개발 규칙

이 문서는 Deskina AI 에이전트의 구조, 핵심 기능, 기술 스택, 그리고 주요 개발 규칙을 정의합니다. AI 어시스턴트는 이 규칙을 숙지하고 개발에 임해야 합니다.

## I. 프로젝트 구조

-   **`client/`**: React와 Electron 기반의 데스크톱 클라이언트 애플리케이션입니다.
    -   **주요 파일**: `client/src/App.js`, `client/src/App.css`
    -   **역할**: UI 렌더링, 사용자 입력 처리, 서버와의 통신, OS 명령어 실행(`child_process`)을 담당합니다.
-   **`server/`**: NestJS 기반의 백엔드 서버입니다.
    -   **주요 파일**: `server/src/gemini/gemini.service.ts`, `server/src/session/session.service.ts`, `server/src/scripts/scripts.service.ts`
    -   **역할**: Gemini API 연동, 시스템 프롬프트 관리, 대화 및 스크립트 세션 관리, DB 연동을 담당합니다.
-   **`prisma/`**: Prisma 스키마(`schema.prisma`)와 데이터베이스 관련 파일을 관리합니다.
    -   **DB 종류**: PostgreSQL (pgvector 확장 기능 사용)

## II. 주요 기술 스택

-   **클라이언트**: React, Electron, `electron-ipc-renderer`, `child_process`
-   **서버**: NestJS, `@google/generative-ai`, Prisma
-   **데이터베이스**: PostgreSQL (Prisma를 통해 관리)
-   **통신**: `fetch` API 스트리밍 방식 (POST)

## III. 핵심 기능 및 동작 원리

### 1. OS 명령어 실행 (`runCommand`)

-   **흐름**:
    1.  사용자가 "C 드라이브 파일 목록 보여줘"와 같은 자연어 명령을 입력합니다.
    2.  클라이언트는 `navigator.platform`으로 현재 OS 정보("win32", "darwin" 등)를 식별하여 서버에 함께 전송합니다.
    3.  서버(`gemini.service.ts`)는 시스템 프롬프트를 통해 AI에게 OS에 맞는 명령어를 생성하도록 지시합니다. (예: Windows -> `dir C:\`, macOS -> `ls -l /`)
    4.  AI는 `runCommand` 액션을 사용하여 실행할 명령어를 응답으로 생성합니다.
    5.  클라이언트(`App.js`)는 `runCommand` 응답을 감지하고, `ipcRenderer`를 통해 메인 프로세스에 명령어 실행을 요청합니다.
    6.  메인 프로세스의 `child_process.exec`가 실제 셸 명령어를 실행하고, 그 결과를 다시 렌더러 프로세스로 보내 UI에 표시합니다.

### 2. 파일 수정 (`editFile`)

-   **흐름**:
    1.  AI가 파일 수정을 위해 `editFile` 액션과 함께 파일 경로(`filePath`) 및 새로운 전체 내용(`newContent`)을 제안합니다.
    2.  클라이언트는 이 제안을 받아 사용자에게 변경 전/후 내용을 보여주는 `react-diff-viewer` 기반의 확인 UI를 표시합니다.
    3.  사용자가 '수락'하면, `ipcRenderer`가 해당 경로에 새로운 내용으로 파일을 덮어씁니다.

### 3. 스크립트 생성 및 실행 (`createScript`, `listScripts`, `runScript`)

-   **흐름**:
    1.  **생성 (`createScript`)**: AI가 사용자의 요청에 따라 Python 코드를 생성하면, 서버는 스크립트 이름, 설명, 코드를 DB의 `Script` 테이블에 저장합니다. DB 스키마는 사용자별로 동일한 스크립트 이름이 중복되지 않도록 강제합니다.
    2.  **목록 (`listScripts`)**: 사용자가 생성한 모든 스크립트 목록을 DB에서 조회하여 보여줍니다.
    3.  **실행 (`runScript`)**:
        -   사용자가 이름으로 스크립트 실행을 요청하면, AI는 `runScript` 액션을 호출합니다.
        -   서버는 DB에서 해당 스크립트의 코드 내용과 파일 경로를 찾아 클라이언트에 전달합니다.
        -   클라이언트는 전달받은 내용으로 로컬에 `.py` 파일을 생성(또는 덮어쓰기)한 후, `child_process`를 통해 실행합니다.
        -   실행 결과는 다시 서버로 전송되어 사용자에게 최종 보고됩니다.

### 4. 이미지 처리 (멀티모달)

-   **흐름**:
    1.  사용자가 이미지를 첨부하면 Base64로 인코딩되어 프롬프트와 함께 서버로 전송됩니다.
    2.  서버는 텍스트와 이미지 데이터를 함께 Gemini API로 전달하여 AI가 이미지를 분석하고 답변을 생성하도록 합니다.

### 5. 페이지네이션

-   **흐름**:
    1.  채팅창 상단의 "이전 대화 불러오기" 버튼을 클릭하면, 클라이언트는 `page`와 `limit` 파라미터를 사용하여 서버에 이전 기록을 요청합니다.
    2.  서버는 Prisma의 `skip`과 `take`을 이용해 DB에서 해당 범위의 데이터를 조회하여 반환합니다.
    3.  클라이언트는 받아온 데이터를 기존 대화 목록의 맨 앞에 추가하고 스크롤 위치를 유지합니다.

## IV. 개발 규칙 및 제약사항

1.  **응답 언어**: 모든 소통, 코드 주석, UI 텍스트는 **한국어**를 기본으로 합니다.
2.  **API 오류 처리**: 서버의 API 컨트롤러 및 서비스(`gemini.service.ts`)는 `try...catch` 블록을 통해 외부 API(Gemini) 호출 오류를 처리해야 합니다. 오류 발생 시, "API 사용량을 초과했습니다."와 같이 사용자 친화적인 메시지를 생성하여 클라이언트에 정확한 형식으로 전달해야 합니다.
3.  **무한 루프 방지**: AI가 특정 작업(특히 명령어 실행) 실패 시 동일한 행동을 반복하지 않도록 시스템 프롬프트에 강력한 제어 규칙을 포함시켜야 합니다.
4.  **상태 관리**: 클라이언트의 상태는 `useState`와 `useRef`를 중심으로 관리하며, 복잡한 전역 상태 관리 라이브러리는 현재 사용하지 않습니다.
5.  **UI/UX**: 기능 구현 시 항상 사용자 경험을 고려해야 합니다. (예: 페이지네이션 시 스크롤 위치 유지, 이미지 미리보기, 명확한 오류 메시지)
6.  **시킨 것만 하기**: 기존에 정상적으로 동작하는 코드에 영향을 주지 않도록, 요청받은 내용만 정확히 수정하고 구현합니다.
7.  **데이터 형식 일관성**: 서버-클라이언트 간 통신 시 데이터 형식을 명확히 이해하고 지켜야 합니다. 특히 SSE 스트림의 `data:` 접두사 파싱과 `payload`의 객체/문자열 형식 처리에 유의해야 합니다.
8.  리팩토링 금지. 절대 리팩토링 하지 않는다. 기존거 수정할 때 고민 또 고민 주의한다.
9.  수정할 때 원인을 모르겠으면 때려맞추지말고, 첫째로 코드를 분석한다. 코드 분석해도 원인을 모르겠으면 진단을 한다. 진단에 사용자의 도움이 필요하면 요청한다. 절대 때려맞춰서 아무거나 수정하지 않는다. 이 부분이 오류가 확실할 때 수정한다.